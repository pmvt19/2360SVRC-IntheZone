#pragma config(UART_Usage, UART1, uartVEXLCD, baudRate19200, IOPins, None, None)
#pragma config(UART_Usage, UART2, uartNotUsed, baudRate4800, IOPins, None, None)
#pragma config(I2C_Usage, I2C1, i2cSensors)
#pragma config(Sensor, I2C_1,  leftDriveQuad,  sensorQuadEncoderOnI2CPort,    , AutoAssign )
#pragma config(Sensor, I2C_2,  rightDriveQuad, sensorQuadEncoderOnI2CPort,    , AutoAssign )
#pragma config(Sensor, I2C_3,  rightLiftQuad,  sensorQuadEncoderOnI2CPort,    , AutoAssign )
#pragma config(Sensor, I2C_4,  leftLiftQuad,   sensorQuadEncoderOnI2CPort,    , AutoAssign )
#pragma config(Sensor, I2C_5,  chainQuad,      sensorQuadEncoderOnI2CPort,    , AutoAssign )
#pragma config(Motor,  port1,           leftWheel,     tmotorVex393HighSpeed_HBridge, openLoop, driveLeft, encoderPort, I2C_1)
#pragma config(Motor,  port2,           leftDrive,     tmotorVex393HighSpeed_MC29, openLoop, reversed, driveLeft)
#pragma config(Motor,  port3,           rightDrive,    tmotorVex393HighSpeed_MC29, openLoop, driveRight)
#pragma config(Motor,  port4,           leftMogo,      tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port5,           rightMogo,     tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port6,           leftLift,      tmotorVex393_MC29, openLoop, reversed, encoderPort, I2C_4)
#pragma config(Motor,  port7,           rightLift,     tmotorVex393_MC29, openLoop, encoderPort, I2C_3)
#pragma config(Motor,  port8,           chainbar,      tmotorVex393_MC29, openLoop, reversed, encoderPort, I2C_5)
#pragma config(Motor,  port9,           claw,          tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port10,          rightWheel,    tmotorVex393HighSpeed_HBridge, openLoop, reversed, driveRight, encoderPort, I2C_2)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

// This code is for the VEX cortex platform
#pragma platform(VEX2)
// Select Download method as "competition"
#pragma competitionControl(Competition)
//Main competition background code...do not modify!
#include "Vex_Competition_Includes.c"
//#include "LCDVex.c"

#define MOTOR_NUM									kNumbOfTotalMotors
#define MOTOR_MAX_VALUE   				127
#define MOTOR_MIN_VALUE						(-127)
#define MOTOR_DEFAULT_SLEW_RATE 	10
#define MOTOR_FAST_SLEW_RATE			256
#define MOTOR_TASK_DELAY					20
#define MOTOR_DEADBAND						10
#define JOY_THRESHOLD							12
// Array to hold requested speed for the motors
int motorReq[ MOTOR_NUM ];
// Array to hold "slew rate" for the motors, the maximum change every time the task
// runs checking current motor speed.
int motorSlew[ MOTOR_NUM ];
//Task - gradually increment/decrements motor speeds to meet new required motor speeds
task MotorSlewRateTask()
{
	unsigned int motorIndex;
	int motorTmp;
	// Initialize stuff
	for(motorIndex=0;motorIndex<MOTOR_NUM;motorIndex++)
	{
		motorReq[motorIndex] = 0;
		motorSlew[motorIndex] = MOTOR_DEFAULT_SLEW_RATE;
	}
	// run task until stopped
	while( true )
	{
		// run loop for every motor
		for( motorIndex=0; motorIndex<MOTOR_NUM; motorIndex++)
		{
			// So we don't keep accessing the internal storage
			motorTmp = motor[ motorIndex ];
			// Do we need to change the motor value ?
			if( motorTmp != motorReq[motorIndex] )
			{
				// increasing motor value
				if( motorReq[motorIndex] > motorTmp )
				{
					motorTmp += motorSlew[motorIndex];
					// limit
					if( motorTmp > motorReq[motorIndex] )
						motorTmp = motorReq[motorIndex];
				}
				// decreasing motor value
				if( motorReq[motorIndex] < motorTmp )
				{
					motorTmp -= motorSlew[motorIndex];
					// limit
					if( motorTmp < motorReq[motorIndex] )
						motorTmp = motorReq[motorIndex];
				}
				// finally set motor
				motor[motorIndex] = motorTmp;
			}
		}
		// Wait approx the speed of motor update over the spi bus
		wait1Msec( MOTOR_TASK_DELAY );
	}
}






// change motor values by changing the desired motor speed in the motorReg array to go through the slwe rate task function

void leftsideDrive( int speed)
{
	motorReq[leftDrive] = speed;
	motorReq[leftWheel] = speed;
}

void rightsideDrive( int speed)
{
	motorReq[rightDrive] = speed;
	motorReq[rightWheel] = speed;
}

void leftsideLift( int speed)
{
	motorReq[leftLift] = speed;
}

void rightsideLift( int speed)
{
	motorReq[rightLift] = speed;
}

void moveMogo( int speed)
{
	motorReq[leftMogo] = speed;
	motorReq[rightMogo] = speed;
}

void moveChain( int speed)
{
	motorReq[chainbar] = speed;
}

void moveClaw( int speed)
{
	motorReq[claw] = speed;
}

//controlling the drive motors through the joysticks
task tankDrive()
{
	int    ctl_l;
	int    ctl_r;
	int    drive_l;
	int    drive_r;

	while( true )
	{
		// Get tank drive vertical joystick control
		ctl_l = vexRT[ Ch3 ]/1.25;
		ctl_r = vexRT[Ch2]/1.25;
		// Ignore joystick near center to prevent motors from running when the joystick doesn't properly center to zero
		if (abs(ctl_l) <= JOY_THRESHOLD)
		{
			drive_l = 0;
		}
		else
		{
			drive_l = (ctl_l)/ (1.25);
		}
		if (abs(ctl_r) <= JOY_THRESHOLD)
		{
			drive_r = 0;
		}
		else
		{
			drive_r = (ctl_r)/ (1.25);
		}
		// Now send out joystick values to motors
		leftsideDrive( drive_l );
		rightsideDrive( drive_r );
		// don't hog CPU
		wait1Msec( 25 );
	}
}
// Proportional-Integral-Derivative(PID) Control Algorithim to accurately hold/move the lift to any position
int desiredLiftTicks = 0;
bool isLiftPID = true;
task PID_Lift()
{
	//Setup the constants for the P, I, and D aspects of the control loop
	//constants determined through experimentation
	const float leftkP = 0.4;
	const float leftkI = 0.002;
	const float leftkD = 0.3;
	const float rightkP = 0.297;
	const float rightkI = 0.002;
	const float rightkD = 0.24;
	int leftError;
	int rightError;
	int leftPrevError = 0 ;
	int rightPrevError = 0;
	int leftIntegral = 0;
	int rightIntegral = 0;
	int leftDeriv;
	int rightDeriv;
	int left_power;
	int right_power;
	while(true)
	{
		//Checks if the the PID control algorithim should be activated or not
		if (isLiftPID == true){
			//Proportional component, calculates the difference between the desired position and the robot's current position
			leftError = desiredLiftTicks - SensorValue[leftLiftQuad];
			rightError = desiredLiftTicks + SensorValue[rightLiftQuad];
			//Integral component, sums up the errors to account for smaller values of error that cannot be rectified
			leftIntegral = leftIntegral + leftError;
			rightIntegral = rightIntegral + rightError;
			//Derivative component, predicts future error by taking the difference of the current and previous error, prevents overshoot
			leftDeriv = leftError-leftPrevError;
			rightDeriv = rightError - rightPrevError;
			//resets the integral component if it becomes too high
			if (rightIntegral > 1000){
				rightIntegral = 0;
			}
			if (leftIntegral > 1000){
				leftIntegral = 0;
			}

			leftPrevError = leftError;
			rightPrevError = rightError;
			//multiply each component by each its repective constant and send it to the motors
			left_power = leftError*leftkP + leftIntegral*leftkI + leftDeriv* leftkD;
			right_power = rightError*rightkP + rightIntegral*rightkI + rightDeriv* rightkD;
			//send power to the motors
			leftsideLift(left_power);
			rightsideLift(right_power);
		}
		wait1Msec(MOTOR_TASK_DELAY);
	}
}

// Proportional-Integral-Derivative(PID) Control Algorithim to accurately hold/move the lift to any position
int desiredChainTicks;
bool isChainPID = true;
task PID_Chainbar()
{
	//Setup the constants for the P, I, and D aspects of the control loop
	//constants determined through experimentation
	const float kP = 0.3;
	const float kI = 0.00;
	const float kD = 0.1;
	int Error;
	int PrevError = 0;
	int Integral = 0;
	int Deriv;
	int chain_power;
	while(true)
	{
		if (isChainPID == true)
		{	//runs through PID loop to ccurately move to any position if PID for the chain is activated
			/*
			Error = desiredChainTicks - SensorValue[chainQuad];
			Integral = Integral + Error;
			Deriv = Error - PrevError;
			if (Integral > 1000){
			Integral = 0;
			}
			PrevError = Error;
			chain_power = 0.9 * (Error*kP + Integral*kI + Deriv* kD);
			moveChain(-1 * chain_power);
			*/

			moveChain(-90 * atan(0.005 * (desiredChainTicks - SensorValue[chainQuad])));


		}
	}
	wait1Msec(MOTOR_TASK_DELAY);
}
int var = 0;
int up = 480;
int par = 1239;
int mult = 200;
int down = 0;


void drive_straight(float dist) // distance in inches
{
	SensorValue[leftDriveQuad] = 0;
	SensorValue[rightDriveQuad] = 0;
	int desiredDriveTicks = (dist/(4* PI))*392;
	while (abs(desiredDriveTicks - SensorValue[leftDriveQuad]) > 5) { //|| desiredDriveTicks - SensorValue[rightDriveQuad] > 5
		leftsideDrive(80* atan(0.01 * (desiredDriveTicks - SensorValue[leftDriveQuad])));
		rightsideDrive(80* atan(0.01 * (desiredDriveTicks + SensorValue[rightDriveQuad])));
	}
	leftsideDrive(0);
	rightsideDrive(0);
}

void drive_turn( float angle)
{
	SensorValue[leftDriveQuad] = 0;
	SensorValue[rightDriveQuad] = 0;
	int speed;
	if (angle > 0) {
		speed = 80;
	}
	else{
		speed = -80	;
	}
	int desiredDriveTicks = abs((((2 *angle * ((7.677 * PI)/360))/(4*PI)) * 392));
	while ((abs(SensorValue[leftDriveQuad]) < desiredDriveTicks) && (abs(SensorValue[rightDriveQuad]) < desiredDriveTicks)){
		leftsideDrive(speed* atan(0.005 * (desiredDriveTicks - SensorValue[leftDriveQuad])));
		rightsideDrive(-1 * speed* atan(0.005 * (desiredDriveTicks - SensorValue[rightDriveQuad])));
	}
	leftsideDrive(0);
	rightsideDrive(0);
}

/*task autoLoader ()
{
isLiftPID = true;
isChainPID = true;
desiredLiftTicks = 170;
desiredChainTicks = 420;
wait1Msec(500);
desiredChainTicks = 1239;
}*/

void drive_t(int speed)
{
	leftsideDrive(speed);
	rightsideDrive(-speed);
}
bool isAuto = false;
int value = 5;
int driverLoadPos = 0; //Tune this value


//LCD Advanced Functions
const char RIGHT_ARROW = 199;
const char LEFT_ARROW = 200;


#ifndef NUM_AUTON_OPTIONS
	#define NUM_AUTON_OPTIONS 1
#endif


#ifndef LEFT_BUTTON
	#define LEFT_BUTTON (nLCDButtons == 1)
#endif
#ifndef MIDDLE_BUTTON
	#define MIDDLE_BUTTON (nLCDButtons == 2)
#endif
#ifndef RIGHT_BUTTON
	#define RIGHT_BUTTON (nLCDButtons == 4)
#endif


string autonOptions[NUM_AUTON_OPTIONS];


void clearLCD(bool backlight = false) {
	bLCDBacklight = backlight;
	clearLCDLine(0);
	clearLCDLine(1);
}


bool tfQuestion(char* question) {
	clearLCD(true);
	displayLCDCenteredString(0, question);
	displayLCDCenteredString(1, "true       false");
	while(true) { //Run until something causes this loop to exit
		if(LEFT_BUTTON) //Left button
			return true;
		if(RIGHT_BUTTON) //Right button
			return false;
	}
}


bool ynQuestion(char* question) {
	clearLCD(true);
	displayLCDCenteredString(0, question);
	displayLCDCenteredString(1, "yes           no");
	while(true) { //Run until something causes this loop to exit
		if(LEFT_BUTTON) //Left button
			return true; //yes
		if(RIGHT_BUTTON) //Right button
			return false; //no
	}
}


int autonomousSelector() {
	int choice = 0;
	clearLCD(true);
	displayLCDCenteredString(0, autonOptions[choice]);
	displayLCDCenteredString(1, "Select");
	displayLCDChar(1, 0, LEFT_ARROW);
	displayLCDChar(1, 15, RIGHT_ARROW);

	while(!MIDDLE_BUTTON) {
		if(LEFT_BUTTON) { //Left button
			choice--; //Decrement the choice
			if(choice < 0)
				choice = NUM_AUTON_OPTIONS - 1;
		displayLCDCenteredString(0, autonOptions[choice]);
			delay(500); //Delay 500 ms

		}

		if(RIGHT_BUTTON) { //Right button
			choice++; //Increment the choice
			if(choice > NUM_AUTON_OPTIONS - 1)
				choice = 0; //Set it to zero
			displayLCDCenteredString(0, autonOptions[choice]);
			delay(500); //Delay 500 ms
		}

	}

	return choice;
}
/*---------------------------------------------------------------------------*/
/*                          Pre-Autonomous Functions                         */
/*                                                                           */
/*  You may want to perform some actions before the competition starts.      */
/*  Do them in the following function.  You must return from this function   */
/*  or the autonomous and usercontrol tasks will not be started.  This       */
/*  function is only called once after the cortex has been powered on and    */
/*  not every time that the robot is disabled.                               */
/*---------------------------------------------------------------------------*/
void pre_auton()
{

	bStopTasksBetweenModes = true;
	// resets all encoder values to zero
	SensorValue[rightDriveQuad] = 0;
	SensorValue[leftDriveQuad] = 0;
	SensorValue[leftLiftQuad] = 0;
	SensorValue[rightLiftQuad] = 0;
	SensorValue[chainQuad] = 0;
	if(LCD_CONNECTED) {

		clearLCD(true);
		displayLCDCenteredString(0, "PLUG IN");
		displayLCDCenteredString(1, "BATTERY #2");
		while( SensorValue[powerExpander] < 500 );//No battery is attached


		autonOptions[0] = "None";
		autonOptions[1] = "Mobile";
		autonOptions[2] = "Stationary";
		autonOptions[3] = "5 Point";
		autonOptions[4] = "10 Point";
		autonOptions[5] = "22 Point";
		leftStart = tfQuestion("Left Side?");
		delay(500);
		autoChoice = autonomousSelector();
		clearLCD(true); //Clear the LCD
		displayLCDCenteredString(0, "Calibrating"); //Set top display
		displayLCDCenteredString(1, "DO NOT TOUCH"); //Set bottom display

	} else {
		leftStart = true; //start on left
		/*
		0 = none
		1 = mobile
		2 = stationary
		3 = 5 point
		4 = 10 point
		5 = 20 point
		*/
		autoChoice = 4;
	}
}
}
/*---------------------------------------------------------------------------*/
/*                                                                           */
/*                              Autonomous Task                              */
/*                                                                           */
/*  This task is used to control your robot during the autonomous phase of   */
/*  a VEX Competition.                                                       */
/*                                                                           */
/*  You must modify the code to add your own robot specific commands here.   */
/*---------------------------------------------------------------------------*/
task autonomous()
{
	startTask(MotorSlewRateTask);
	startTask(PID_Chainbar);
	startTask(PID_Lift);
	isChainPID = false;
	isLiftPID = false;


	drive_turn(180);


}
/*---------------------------------------------------------------------------*/
/*                                                                           */
/*                              User Control Task                            */
/*                                                                           */
/*  This task is used to control your robot during the user control phase of */
/*  a VEX Competition.                                                       */
/*                                                                           */
/*  You must modify the code to add your own robot specific commands here.   */
/*---------------------------------------------------------------------------*/
task usercontrol()
{
	// User control code here, inside the loop
	startTask( MotorSlewRateTask );
	startTask(PID_Chainbar);
	startTask( tankDrive );
	startTask(PID_Lift);

	isLiftPID = false;
	isChainPID = false;
	isAuto = false;
	clearLCDLine(0);                                            // Clear line 1 (0) of the LCD
	clearLCDLine(1);                                            // Clear line 2 (1) of the LCD

	bLCDBacklight = true;
	displayLCDCenteredString(0, "2360S");
	displayLCDCenteredString(1, "SubZERO");


	while (true)
	{
		//preset controls(other than drive)
		if (vexRT[Btn5UXmtr2] == 1)
		{
			isChainPID = false;
			moveChain(120);
		}
		else if (vexRT[Btn5DXmtr2] == 1)
		{
			isChainPID = false;
			moveChain(-120);
		}
		else if	(isChainPID == false)
		{
			moveChain(0);
		}
		//chain presets
		//int counter  = 0;
		if (vexRT[Btn7UXmtr2] == 1)
		{
			//counter = counter + 10;
			isChainPID = true;
			desiredChainTicks = 435 ;

		}
		else if (vexRT[Btn7LXmtr2] == 1)
		{
			isChainPID = true;
			desiredChainTicks = 1239;
		}
		else if( vexRT[Btn7DXmtr2] == 1)
		{
			isChainPID = true;
			desiredChainTicks = 1455;
		}
		else if(vexRT[Btn7U] == 1)
		{
			isChainPID = true;
			desiredChainTicks = 435 ;
			//counter = counter + 10;

		}
		else if(vexRT[Btn7L])
		{
			isChainPID = true;
			desiredChainTicks = 1239;
		}
		else if(vexRT[Btn7D])
		{
			isChainPID = true;
			desiredChainTicks = 1239;
		}

		/*if(vexRT[Ch3Xmtr2] == 127)
		{
			isChainPID = true;
			desiredChainTicks = 1239;
		}
		else if (vexRT[Ch3Xmtr2] == -127)
		{
			isChainPid = true;
			desiredChainTicks = 435;
		}
		else if(vexRT[Ch3Xmtr2] < 120 && vexRT[Ch3Xmtr2] != 0)
		{
			isChainPID = false;
			moveChain(-40);
		}
		else
		{
			isChainPID = false;
			moveChain(0);
		}*/

		/*
		else
		{
		isLiftPID = false;
		isChainPID = false;
		}
		*/



		/*if (time1[T1] >= 3000){
		isChainPID = false;
		}
		/*
		else if (vexRT[Btn7DXmtr2] == 1)
		{
		isChainPID = true;
		desiredChainTicks = 1319;
		}
		*/
		// Mobile goal controls
		if (vexRT[Btn8U] == 1)
		{
			moveMogo(110);
		}
		else if (vexRT[Btn8D] == 1)
		{
			moveMogo(-110);
		}
		else
		{
			moveMogo(0);
		}
		if (vexRT[Btn6UXmtr2]== 1)
		{
			motorReq[claw] = -45;
		}
		else if (vexRT[Btn6DXmtr2]== 1)
		{
			motorReq[claw] = 127;
		}
		else
		{
			motorReq[claw] = 0;
		}
		if (vexRT[Btn6U] == 1)
		{
			isLiftPID = false;
			leftsideLift(100);
			rightsideLift(100);
		}
		else if (vexRT[Btn6D] == 1)
		{
			isLiftPID = false;
			leftsideLift(-80);
			rightsideLift(-80);
		}
		else if(isLiftPID == false)
		{
			leftsideLift(0);
			rightsideLift(0);
		}
		/*	if(vexRT[Btn8RXmtr2])
		{
		desiredLiftTicks = 190;
		moveClaw(45);
		wait1Msec(800);

		}
		else
		{

		}*/
		if(vexRT[Btn8R] == 1)
		{
			isAuto = true;
		}
		else if (vexRT[Btn8L] == 1)
		{
			isAuto = false;
		}



		wait1Msec(20);
	}
}
